@model _744Project.ViewModels.NetworkViewModel

@{
    ViewBag.Title = "Network";
}
<link rel="stylesheet" type="text/css" href="http://cdnjs.cloudflare.com/ajax/libs/qtip2/2.2.0/jquery.qtip.css">


<!--Here is where the popup MODAL javascript is going. This is for when the nodes are clicked on-->
<div class="modal fade" id="myModal" role="dialog">
	<div class="modal-dialog">

		<!-- Modal content-->
		<div class="modal-content">
			<div class="modal-header">
				<button type="button" class="close" data-dismiss="modal">&times;</button>
				<h4 class="modal-title">Network Element Overview</h4>
			</div>
			<div id="NodePopup" class="modal-body">

			</div>
			<div class="modal-footer">
				<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
			</div>
		</div>

	</div>
</div>
<!-- End of Modal section -->



<div class="row">
    <div class="panel panel-default" style="margin-top:10px">
        <div class="panel-body">
            <div class="col-sm-4">
                <button class="PauseButton btn btn-danger">pause</button>
                <button class="PlayButton btn btn-success">play</button>
            </div>
            <div class="col-sm-4">
                <h3 style="text-align: center;vertical-align: middle;">Network Layout</h3>
            </div>
            <div class="col-sm-4" style=" display: flex; align-items: center; justify-content: center;">
                <input id="clickMe" style="display: block; margin-top: 10px;" class="btn btn-default" type="button" value="Save Configuration" onclick="exportPositions();" />
            </div>
        </div>
    </div>
</div>

<div class="panel panel-default" style=" height: 500px; width:100%;">
    <div id="cy" class="panel-body" style="height: 500px; width:100%;">
    </div>
</div>


<div class="panel panel-default">
    <div class="panel-body">
        <div class="row">
            <table class="table table-bordered">
                <tr><th>Transaction Id</th><th>Store Ip</th><th>Encrypted Amount</th><th>Action</th></tr>
                @foreach (var trans in Model.transactions)
                {
                    <tr>
                        <td>@trans.Id</td>
                        <td>@trans.storeIp</td>
                        <td>@trans.transactionAmount</td>
                        <td id="@trans.Id"><button class="SendTransaction btn btn-default" id="@trans.storeIp">Send</button></td>
                    </tr>
                }
            </table>

        </div>
        <div class="col-sm-4" style="color:Red;text-align: center;vertical-align: middle; text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;">
            Processing Center
        </div>
        <div class="col-sm-4" style="color:Blue;text-align: center;vertical-align: middle; text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;">
            Relay
        </div>
        <div class="col-sm-4" style="color:Yellow;text-align: center;vertical-align: middle; text-shadow: -1px 0 black, 0 1px black, 1px 0 black, 0 -1px black;">
            Store
        </div>

    </div>
</div>


<style type="text/css">
    body {
        background-image: url(../../stock-internet.jpg);
    }
</style>

<script src="http://code.jquery.com/jquery-2.0.3.min.js"></script>
<script src="http://cdnjs.cloudflare.com/ajax/libs/qtip2/2.2.0/jquery.qtip.js"></script>
<script src="@Url.Content("~/Scripts/cytoscape.js")" type="text/javascript"></script>
<script src="@Url.Content("~/Scripts/cytoscape-qtip.js")" type="text/javascript"></script>
@section Scripts{

    <script>

		/* ================================================================================================
											Cytoscape SETUP SECTION
		===================================================================================================*/

		//This converts the Model into JSON data
	   var jsonData = @Html.Raw(Json.Encode(Model));
	   console.log(jsonData);

	var processingCenter = 0;

	var NetworkElements = {
		nodes: [],
		edges: []
	};

	//initializes the Cytoscape object. (This is what the graph is)
	var cy = cytoscape({
        container: document.getElementById('cy'),
        style:
        [
			{
				selector: 'node',
				style: {
					'border-width': '5',
					//'background-color': 'red',
					'background-color': 'data(color)',
					content: 'data(id)',
                    'curve-style': 'bezier',
                    'shape': 'data(shape)',
                    'width': 'data(width)',
                    'height': 'data(height)'
                },
			},
			{
				selector: 'edge',
				style: {
                    'label': 'data(weight)',
                    'line-color':'data(color)'
				}
            },
            {
                selector: ':selected',
                css: {
                    'background-color': 'grey',
                    'line-color': 'grey',
                }
            },
            {
                selector: '.block',
                css: {
                    'background-color': 'black',
                    'line-color': '#990000'
                }
            },
            {
                selector: '.liveRelay',
                css: {
                    'background-color': '#4d88ff',
                }
            },
            {
                selector: '.liveGate',
                css: {
                    'background-color':'green'
                }
            },
            {
                selector: '.liveConnection',
                css: {
                    'line-color': 'grey'
                }
            }
        ],
		layout: {
			name: 'preset'
		},
		//RIGHT HERE IS WHERE I GET THE ELEMENTS FROM THE MODEL
		elements: convertToCytoscape()
	});
      
	// This function converts the JSON representation of the Model into the Cytoscape elements
	function convertToCytoscape() {
		//alert("hi");
		//console.log("Hello..");
		console.log(jsonData.regions);

        //change to use region
        NetworkElements.nodes.push({ data: { id: 1, color: '#d4c4c4', shape: 'rectangle', width: 30, height: 30 } });
        NetworkElements.nodes.push({ data: { id: 2, color: '#d4c4c4', shape: 'rectangle', width: 30, height: 30 } });
        NetworkElements.nodes.push({ data: { id: 3, color: '#d4c4c4', shape: 'rectangle', width: 30, height: 30 } });
        NetworkElements.nodes.push({ data: { id: 4, color: '#d4c4c4', shape: 'rectangle', width: 30, height: 30 } });

        for (var p in jsonData.regions) {
            var xLocation = 0;
            var yLocation = 0;
            for (var i in jsonData.regions[p].networkEntities) {
                 //if it is a store
                if (jsonData.regions[p].networkEntities[i].type == 0) {
                    NetworkElements.nodes.push({ data: { id: i, color: 'yellow', shape: 'octagon', parent: p, width: 30, height: 30, category: 0, queue:[], limit:5, databaseId: jsonData.regions[p].networkEntities[i].databaseId }, position: { x: jsonData.regions[p].networkEntities[i].x, y: jsonData.regions[p].networkEntities[i].y } });
                }
                //if it is a relay
                else if (jsonData.regions[p].networkEntities[i].type == 1) {
                    if (jsonData.regions[p].networkEntities[i].isGateway) {//gateway represent other color
                        if (jsonData.regions[p].networkEntities[i].isActive) {
                            NetworkElements.nodes.push({ data: { id: i, color: 'green', shape: 'rectangle', parent: p, width: 30, height: 30, category: 1, queue: [], limit: 100, isActive: jsonData.regions[p].networkEntities[i].isActive, databaseId: jsonData.regions[p].networkEntities[i].databaseId }, position: { x: jsonData.regions[p].networkEntities[i].x, y: jsonData.regions[p].networkEntities[i].y } });
                        } else {
                            NetworkElements.nodes.push({ data: { id: i, color: 'black', shape: 'rectangle', parent: p, width: 30, height: 30, category: 1, queue: [], limit: 100, isActive: jsonData.regions[p].networkEntities[i].isActive, databaseId: jsonData.regions[p].networkEntities[i].databaseId }, position: { x: jsonData.regions[p].networkEntities[i].x, y: jsonData.regions[p].networkEntities[i].y } });
                        }
                    } else {
                        if (jsonData.regions[p].networkEntities[i].isActive) {
                            NetworkElements.nodes.push({ data: { id: i, color: '#4d88ff', shape: 'rectangle', parent: p, width: 30, height: 30, category: 1, queue: [], limit: 10, isActive: jsonData.regions[p].networkEntities[i].isActive, databaseId: jsonData.regions[p].networkEntities[i].databaseId }, position: { x: jsonData.regions[p].networkEntities[i].x, y: jsonData.regions[p].networkEntities[i].y } });
                        } else {
                            NetworkElements.nodes.push({ data: { id: i, color: 'black', shape: 'rectangle', parent: p, width: 30, height: 30, category: 1, queue: [], limit: 10, isActive: jsonData.regions[p].networkEntities[i].isActive, databaseId: jsonData.regions[p].networkEntities[i].databaseId }, position: { x: jsonData.regions[p].networkEntities[i].x, y: jsonData.regions[p].networkEntities[i].y } });
                        }
                    }
                }
            }
		}
		console.log("===========================================================================================");
        //add processing center which is from processingCenter
        NetworkElements.nodes.push({ data: { id: jsonData.processingCenter.ip, color: 'red', shape: 'triangle', width: 70, height: 70, category: 2, queue: [], limit:1000, databaseId: jsonData.processingCenter.databaseId }, position: { x: jsonData.processingCenter.x, y: jsonData.processingCenter.y } });

		//console.log("===========================================================================================");
		for (var q in jsonData.connections) {
            //console.log(jsonData.connections[q]);
            NetworkElements.edges.push({ data: { id: jsonData.connections[q].ip1 + jsonData.connections[q].ip2, color:'grey', source: jsonData.connections[q].ip1, target: jsonData.connections[q].ip2, weight: jsonData.connections[q].weight, isActive: true, type1: jsonData.connections[q].type1, type2: jsonData.connections[q].type2 } });
        }
		return NetworkElements;
        }

        
        //console.log("after emptying the networkelement, ", NetworkElements);

	/* ================================================================================================
										EXPORT NODE POSITION SECTION
	===================================================================================================*/

	// this sends the (X,Y) locations of the nodes to the database to be stored.
	function exportPositions() {//cy
		var list = [];
		var nodes = cy.nodes();
		console.log(nodes);
		console.log("=============================");
        for (var i = 0; i < nodes.length; i++) {
            var obj = {};
            obj['id'] = nodes[i].id();
			obj['pos'] = nodes[i].position();
			console.log(jsonData.networkEntities);
			console.log(nodes[i]);
			if (nodes[i].id() != 1 && nodes[i].id() != 2 && nodes[i].id() != 3 && nodes[i].id() != 4) {
				console.log(jsonData.networkEntities[obj['id']]);
				//obj['category'] = jsonData.networkEntities[obj['id']].type;//nodes[i].category;
				obj['isActive'] = jsonData.networkEntities[obj['id']].isActive;
			}
			else {
				//obj['category'] = -1;
				obj['isActive'] = true;
			}

            list.push(obj);
        }

		list = JSON.stringify({
			'nodePosition': list
		});

		console.log(list);

		var url = '/Network/NodePositions';//'Network/NodePositions';
		$.ajax({
			type: 'POST',
			url: url,
			data: list,
			dataType: 'json',
			contentType: 'application/json;charset=utf-8',
			success: function (data) { alert(data); },
			failure: function (errMsg) {
				alert(errMsg);
			}
		});
	}

    /* ================================================================================================
										Find the shortest path
	===================================================================================================*/
        var backQueue;
        function Graph() {
            var neighbors = this.neighbors = {};
            this.addRREdge = function (u, v) {
                if (neighbors[u] === undefined) { 
                    neighbors[u] = [];
                }
                neighbors[u].push(v);
                if (neighbors[v] === undefined) { 
                    neighbors[v] = [];           
                }                                  
                neighbors[v].push(u);              
            };
            this.addEdge = function (u, v) {
                if (neighbors[u] === undefined) {
                    neighbors[u] = [];
                }
                neighbors[u].push(v);
            };
            //this.addNode = function (u) {
            //    if (neighbors[u] === undefined) {
            //        neighbors[u] = [];
            //    }
            //}
            return this;
        }

        function shortestPath(graph, source, target) {
            if (source === target) {   
                console.log(source);  
                return;               
            }
            var queue = [source],
                visited = { source: true },
                predecessor = {},
                tail = 0;
            //console.log("before loop, queue", queue);
            while (tail < queue.length) {
                var u = queue[tail++],  
                    neighbors = graph.neighbors[u];
                //console.log("in while loop, graph.neighbors", graph.neighbors);
                //console.log("shortest path u", u, "neighbors", neighbors);
                if (!neighbors) {
                    return { err: "This way is block" };
                    break;
                }
                for (var i = 0; i < neighbors.length; ++i) {
                    var v = neighbors[i];
                   // console.log("for loop, v = ", v)
                    if (visited[v]) {
                        continue;
                    }
                    visited[v] = true;
                    if (v === target) {   
                        var path = [v];   
                        while (u !== source) {
                            path.push(u);
                            u = predecessor[u];
                        }
                        path.push(u);
                        path.reverse();
                        return path;
                    }
                    predecessor[v] = u;
                    queue.push(v);
                }
            }
            console.log('there is no path from ' + source + ' to ' + target);
            return;
        }
        console.log("element network", NetworkElements);
        var inActivatedNodes = [];
        var activeNodes = [];
        function makeAGraph() {
            inActivatedNodes = [];
            activeNodes = [];
            var graph = new Graph();
            NetworkElements.nodes.forEach(function (node) {
                if (node.data.category) {
                    console.log("category,", node.data.category)
                    if (node.data.category == 1) {
                        if (!node.data.isActive) {
                            inActivatedNodes.push(node.data.id);
                        } else {
                            activeNodes.push(node.data.id);
                        }
                    } else {
                        console.log("is active");
                        return true;
                    }
                    //console.log("make a graph", node.data)
                }
            });
            console.log("inActiveNodes: ", inActivatedNodes);
            console.log("ActiveNodes: ", activeNodes);
            //console.log("before changing inactiveated node :", NetworkElements.edges);

            //handle if this relay is activated, if it's inactivated, find that relay through ip, then set it as false
            if (inActivatedNodes) {
                NetworkElements.edges.forEach(function (edge) {
                    if (inActivatedNodes.indexOf(edge.data.source) >= 0) {
                        edge.data.isActive = false;
                        console.log("find shortest path, that edges source: ", edge.data);
                    }
                });
                NetworkElements.edges.forEach(function (edge) {
                    //console.log("=================", inActivatedNodes.indexOf(edge.data.target));
                    if (inActivatedNodes.indexOf(edge.data.target) >= 0) {
                        edge.data.isActive = false;
                        console.log("find shortest path, that edges target: ", edge.data);
                    }
                });
            } 
            NetworkElements.edges.forEach(function (edge) {
                if (activeNodes.indexOf(edge.data.source) >= 0 && inActivatedNodes.indexOf(edge.data.target)<0) {
                        edge.data.isActive = true;
                    }
                });
                NetworkElements.edges.forEach(function (edge) {
                    if (activeNodes.indexOf(edge.data.target) >= 0 && inActivatedNodes.indexOf(edge.data.source) < 0) {
                        edge.data.isActive = true;
                    }
                });
            
           
            //console.log("after changing inactiveated node :", NetworkElements.edges);

            NetworkElements.edges.forEach(function (edge) {
                if (edge.data.isActive) {
                    if (isRRConnection(edge.data.source, edge.data.target)) {
                        graph.addRREdge(edge.data.source, edge.data.target);
                    } else {
                        graph.addEdge(edge.data.source, edge.data.target);
                    }
                }
            });
            return graph;
        }

        function isRRConnection(sourceIP, targetIP) {
            var sourceType, targetType;
            NetworkElements.nodes.forEach(function (node) {
                if (node.data.id === sourceIP) {
                    sourceType = node.data.category;
                }
            });
            NetworkElements.nodes.forEach(function (node) {
                if (node.data.id === targetIP) {
                    targetType = node.data.category;
                }
            });
            if (sourceType == 1 && targetType == 1) {
                return true;
            } else {
                return false;
            }
        }
       // test();
         function test() {
            var graph = makeAGraph();
             //console.log("graph", graph);
            var result = shortestPath(graph, "192.168.0.24", "192.168.0.1");
            console.log("test result", result);
        }

         function findShorestPath(sourceIP) {
             var graph = makeAGraph();
             pathQueue = [];
             pathQueue = shortestPath(graph, sourceIP, "192.168.0.1");
             if (pathQueue == undefined) {
                 return alert("Way is block, no way to Processing center");
             }
             //console.log("making graph", graph)
         }

	/* ================================================================================================
										Send Transaction SECTION
		-This is called when one of the "send" buttons are clicked next to a transaction on the bottom of the main screen
		-Currently:
			-the transaction is sent to the Processing Center's queue (where it can then be seen once the PC is clicked on)
		-What needs to be done:
			-compute the path and implement the queues between nodes
	===================================================================================================*/
		var processingCenterQueue = []; //once the AJAX call is made (for clicking on a Processing Center), this is used to
										// show what is on the queue. The call pulls the GetNodeInformation.cshtml into the
										//javascript modal as a partial view. You can see in the javascript of that page
										// that it dynamically adds the items in the queue to its HTML with a for each loop
				//you are going to want to do this for general relays and their queues. it will be the same process, but the 
				//data will be coming from a different place.
        var queue = [];
		// When one of the transaction "Send" buttons are clicked, this is called which starts the animation
        $(".SendTransaction").click(function () {
			// Holds the product ID of the clicked element,this code is just for the old animation
			var storeIp = $(this).attr('id');
			var transitionID = document.getElementById(storeIp).parentNode.id;
            queue.push(transitionID);
            findShorestPath(storeIp);
            console.log("node ip queue ", pathQueue);
            backQueue = pathQueue.slice(0);
            //console.log("pathqueue.length,", pathQueue.length);
            generateAnimation(storeIp, pathQueue, pathQueue.length);

            //======================================↑ new function to find shortest path=======================================================================
   //         var pathToJ = dijkstra.pathTo(cy.getElementById(storeIp));
   //         var i = pathToJ.length;
			//recursivePath(pathToJ, pathToJ[i - 1], i - 1);


			//TEMPORARY TO DEMONSTRATE HOW TO USE THE PROCESS TRANSACTION FUNCTIONALITY
			//This just sends the transaction straight to the processingCenterQueue, where it can then be processed
			var transactionId = $(this).parent().attr("id");
			//console.log("Transactdion: " + transactionId);
			processingCenterQueue.push(transactionId);
			//console.log(processingCenterQueue);
		});


	/* ================================================================================================
										ANIMATION SECTION
	===================================================================================================*/
        var animations = [];
        var transitionQueue = [];
        var nodePath = [];
        function sleep(time) {
            return new Promise((resolve) => setTimeout(resolve, time));
        }

	//Calculates the shortest path to the Processing Center
	//var dijkstra = cy.elements().dijkstra(cy.getElementById(processingCenter), function (edge) {
	//	console.log(processingCenter);
	//	//console.log(cy.elements());
	//	return edge.data('weight');
	//});
        
	

	//This function recursively calls itself to do the animation from node to node. the elements from the Store to the Processing
	// Center are stored in the 'stack' parameter, while the current element is the 'item', and the current index is 'i'.
	//once this is done, it calls the promise function, which reverses the animation by calling backTrackAnimation
        function generateAnimation(source, nodeList, length) {
            console.log("Animation source", source);
            var ann = cy.getElementById(source).animation({
                style: {
                    'background-color': 'white',
                    'line-color': 'white',
                    'width': 50,
                    'height': 50
                },
                duration: 1000
            });
            animations.push(ann);
            nodeList.shift()
            // nodePath.push(nodeList.shift());
            //console.log("nodePath", nodePath);
            //test the pre node whether have the queue in node 
            //var testRecord = nodeList.shift();
            // if (testRecord) {
            //     NetworkElements.nodes.forEach(function (node) {
            //         if (node.data.id == testRecord) {
            //             console.log("when do the animation, queue of pre node : ", node.data.queue);
            //         }
            //     });
            // }
            /* ↑ ↑↑↑↑↑↑↑test↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑*/
            NetworkElements.nodes.forEach(function (node) {
                if (node.data.id == source) {
                    if (node.data.limit > 0) {
                        node.data.queue.push(queue.pop());
                    }
                    console.log("when do the animation, queue of current node", node.data.queue);
                }
            });

            ann.play().promise('completed').then(function () {
                ann.reverse().rewind().play();
                console.log("animation length: ",length);
                animations.pop();
                if (length > 1) {
                        NetworkElements.nodes.forEach(function (node) {
                            if (node.data.id == source) {
                                queue.push(node.data.queue.pop());
                            }
                        });
                        return generateAnimation(nodeList[0], nodeList, nodeList.length);
                } else {
                     console.log("finish transt from to processing center: ", queue);
                }
            });
        }
        //function recursivePath(stack, item, i) {
        //    console.log("item", item._private.data.id);
        //    console.log("stack", stack);
        //    var ann = cy.getElementById(item._private.data.id).animation({
        //        style: {
        //            'background-color': 'white',
        //            'width': 50,
        //            'height': 50
        //        },
        //        duration: 1000
        //    });
        //    animations.push(ann);

        //    ann
        //        .play() // start
        //        .promise('completed').then(function () { // on next completed
        //            i--;
        //            ann.reverse().rewind().play();
        //            animations.pop();
        //            if (i > 0) { // was >=
        //                return recursivePath(stack, stack[i], i); // i
        //            }
        //            return backTrackAnimation(stack, stack[0], 0);
        //        });
        //}
	//This function is exactly the same as the recursivePath function, except it goes from the ProcessingCenter back to the Store.
        function backToStore(processingCenter, nodeList, length) {
            console.log("Animation source", processingCenter);
            var ann = cy.getElementById(processingCenter).animation({
                    style: {
                        'background-color': 'green',
                        'width': 50,
                        'height': 50
                    },
                    duration: 1000
                });
                animations.push(ann);
                nodeList.shift()
                NetworkElements.nodes.forEach(function (node) {
                    if (node.data.id == processingCenter) {
                        if (node.data.limit > 0 && queue.pop() !== undefined) {
                            node.data.queue.push(queue.pop());
                        }
                        console.log("when do the animation, queue of current node", node.data.queue);
                    }
                });

                ann.play().promise('completed').then(function () {
                    ann.reverse().rewind().play();
                    console.log("animation length: ", length);
                    animations.pop();
                    if (length > 1) {
                            NetworkElements.nodes.forEach(function (node) {
                                if (node.data.id == processingCenter) {
                                    queue.push(node.data.queue.pop());
                                }
                            });
                         return generateAnimation(nodeList[0], nodeList, nodeList.length);
                    } else {
                        console.log("finish transt from to processing center: ", queue);
                    }
                });
            
        }
       
	//function backTrackAnimation(stack, item, i) {
	//	var ann = cy.getElementById(item._private.data.id).animation({
	//		style: {
	//			'background-color': 'green',
	//			'width': 50,
	//			'height':50
	//		},
	//		duration: 1000
	//	});
	//	animations.push(ann);

	//	ann
	//		.play() // start
	//		.promise('completed').then(function () { // on next completed
	//			ann.reverse().rewind().play();
	//			animations.pop();
	//			i++;
	//			if (i < stack.length) {
	//				return backTrackAnimation(stack, stack[i], i);
	//			}
	//			resetElements(stack);
	//			return;
	//		});
	//}

	//Not used yet, but this method is called once the animation is complete.
	function resetElements(stack) {
		/*console.log("DONE+====================");
		cy.style().resetToDefault() ;
		stack.forEach(function (element) {
			console.log(element);
		});*/
	}


		/* ================================================================================================
										PAUSE/PLAY SECTION
		===================================================================================================*/


		//Working on pause and play, however it only works with one element on the "animation list" at a time.
		//This is because there are multiple "threads"/"listeners" which begin each animation cycle, so the animations
		//aren't running concurrently. To do more than one, there will have to be a way to either tie them together,
		//or use some sort of javascript Mutex / Lock that must be used .
		$(".PauseButton").click(function () {
			console.log("Stopped!");
			animations.forEach(function (element) {
				console.log(element);
				element.pause();
			});
		});

		$(".PlayButton").click(function () {
			animations.forEach(function (element) {
				console.log(element);
				element.play();
			});
		});


		/* ================================================================================================
										Modal Popup section (clicking on an element in the graph)
		===================================================================================================*/

		//When you click on a connection,
		cy.on('click', 'edge', function (event) {
			var source = this.data('source');
			var target = this.data('target');
			var type1 = this.data('type1');
			var type2 = this.data('type2');
			var isActive = this.data('isActive');
			console.log("source: " + this.data('source'));
			console.log("target: " + this.data('target'));
			console.log(type1 + " " + type2 + " " + isActive);

			if (source != null && target != null) {
				var DEST = "/Network/GetConnection?source="+source+"&target="+target+"&type1="+type1+"&type2="+type2;
				$.ajax({
					url: DEST,
					contentType: 'application/html; charset=utf-8',
					type: 'GET',
					dataType: 'html'

				})
                    .success(function (result) {
                        console.log("has go through here");
						$("#NodePopup").html(result);
						$("#myModal").modal()
						/*if (type == 2) {
							console.log("PC clicked ... ");
							processingCenterQueue.forEach(function (element) {
								console.log(element);
								$("#PCTransactionList").append('<div class="btn btn-default processTransactionBtn" id="' + element + '"onclick="processTransactionButton(' + element + ')">' +
									'Process transaction: ' + element +
									'</div>');
							});
						}*/
                        //console.log("edge info: ", result);
					})
					.error(function (xhr, status) {
						alert(status);
					})
			}
			else {
				$("#NodePopup").html("");
			}
		});

		//When you click a node, popup for info
		cy.on('click', 'node', function (evt) {
			popupInformation(this.data('databaseId'), this.data('category'));// sending popupInformation(Id, node type)

		});

		function popupInformation(id,type) {
			console.log(id + " clicked!");
			//return;
            console.log("type: ", type);
			if (id != null ){//&& type != 2) {
				var DEST = "/Network/GetNodeInformation?id=" +id+"&type="+type;
				$.ajax({
					url: DEST,
					contentType: 'application/html; charset=utf-8',
					type: 'GET',
					dataType: 'html'

				})
                    .success(function (result) {
                        //console.log("what is the result", result);
						$("#NodePopup").html(result);
                        $("#myModal").modal();
                        if (type == 2) {
                            NetworkElements.nodes.forEach(function (node) {
                                if (node.data.databaseId == id) {
                                    node.data.queue.forEach(function (item) {
                                        $('<div>' + item + '</div>').appendTo($('#modalQueue'));
                                        $("#PCTransactionList").append('<div class="btn btn-default processTransactionBtn" id="' + item + '"onclick="processTransactionButton(' + item + ')">' +
                                            'Process transaction: ' + item +
                                            '</div>');
                                    });
                                }
                            });
                            console.log("PC clicked ... ");
                            //processingCenterQueue.forEach(function (element) {
                            //    $("#PCTransactionList").append('<div class="btn btn-default processTransactionBtn" id="' + element + '"onclick="processTransactionButton(' + element + ')">' +
                            //        'Process transaction: ' + element +
                            //        '</div>');
                            //});
                        }
                        else if (type == 1) {
                            NetworkElements.nodes.forEach(function (node) {
                                if (node.data.databaseId == id && node.data.category == type) {
                                    node.data.queue.forEach(function (item) {
                                        $('<div>' + item + '</div>').appendTo($('#modalQueue'));
                                    });

                                }
                            });
                        }
                        else if (type == 0) {
                            NetworkElements.nodes.forEach(function (node) {
                                //console.log("node id: ", node.data.id, "id :", id);
                                if (node.data.databaseId == id && node.data.category == type) {
                                    node.data.queue.forEach(function (item) {
                                        $('<div>' + item + '</div>').appendTo($('#modalQueue'));
                                    });

                                }
                            });
                        }
					})
					.error(function (xhr, status) {
						alert(status);
					})
			}
			/*else if (itype == 2) {
				console.log("PC clicked...");
			}*/
			else {
				$("#NodePopup").html("");
			}


		}

		//this is the activate/inactivate for aconnection
		function ActivateCon(sourceIp, sourceType, targetIp, targetType) {
			var obj = {};
			obj['sourceIp'] = sourceIp;
			obj['sourceType'] = sourceType;
			obj['targetIp'] = targetIp;
			obj['targetType'] = targetType;
			obj = JSON.stringify(obj);

			//still need to set the js element back
            let changeID, changeIsActive;
			//change in the network elements
			NetworkElements.edges.forEach(function (el) {
                if (el.data.id == (sourceIp + "" + targetIp)) {
                    changeID = el.data.id;
                    console.log("el.data.id: ",el.data.id)
                    console.log("CHANGING ACTIVE OF CONNECTION");
                    console.log("before chaing the status: ", el.data.isActive);
					el.data.isActive = !el.data.isActive;
                    console.log("after changing the status: " + el.data.isActive);
                    changeIsActive = el.data.isActive;
				}
			});
            changeColor(changeID, "edge", changeIsActive);
			//ajax call
			//this ajax call updates the database
			var url = '/Network/SaveConInformation';
			$.ajax({
				type: 'POST',
				url: url,
				data: obj,
				dataType: 'json',
				contentType: 'application/json;charset=utf-8',
				success: function (data) {
					console.log("after successfully call ajax, data: ", data)
					alert(data);
					$("#NodePopup").html("");
					$("#NodePopup").modal('hide');
				},
				//error: function (errMsg) {
				//	alert("not update the data");
				//	$("#NodePopup").html("");
				//}
			});
			//hides the modal after success
			$("#NodePopup").html("");
			$('#myModal').modal('hide')
		}
        function changeColor(id, type, isActive) {
            if (type == "relay") {
                if (isActive) {
                    console.log("==============================");
                    cy.getElementById(id).classes('liveRelay');
                } else {
                    console.log("+++++++++++++++++++++++++++++++");
                    cy.getElementById(id).classes('block');
                }
            } else if (type == "gateway") {
                console.log("gateway active: ", isActive);
                console.log("change color id: ", id);
                if (isActive) {
                    console.log("==============================");
                    cy.getElementById(id).classes('liveGate');
                } else {
                    console.log("+++++++++++++++++++++++++++++++");
                    cy.getElementById(id).classes('block');
                }
            } else {
                console.log("change edge id: ", id);
                console.log("change edge type: ", type);
                console.log("change edge isActive: ", isActive);
                if (isActive) {
                    console.log("==============================");
                    cy.getElementById(id).classes('edge');
                } else {
                    console.log("+++++++++++++++++++++++++++++++");
                    cy.getElementById(id).classes('block');
                }
            }
        }
		// this is the activate / inactivate
		function Activate(id, type, ip) { //type 1 is relay
			//console.log("testing 1 2 3");
			//console.log(id);
			if (id != null) {
				var list = [];
				var obj = {};
				obj['id'] = id;
				//obj['isActive'] = Model.isActive;
				obj['type'] = type;
				list.push(obj);
				list = JSON.stringify({
					'nodePosition': list
				});
				obj = JSON.stringify(obj);
				console.log(obj);

				//sets the javascript value (of isActive) to true/ false
				var element = cy.getElementById(ip);
				//var element = cy.$('#' + ip);
				console.log(ip);
				console.log(element);
				console.log("node infomation: ",element._private.data);

				//this js call updates the active/inactive in the js
				//console.log("Before the cy.element._private.isActive is changed: " + element._private.data.isActive);
				//element.data('isActive', !element._private.data.isActive);
                //console.log("After the cy.element._private.isActive is changed: " + element._private.data.isActive);
                let changeID, changeIsActive, changeType;
				NetworkElements.nodes.forEach(function (node) {
                    if (node.data.id == ip) {
                        changeID = node.data.id;
                        console.log("After the NetworkElement.isActive is changed: " + node.data.isActive);
                        node.data.isActive = !node.data.isActive;
                        console.log("After the NetworkElement.isActive is changed: " + node.data.isActive);
                        changeIsActive = node.data.isActive;
                        if (node.data.limit > 50) {
                            changeType = "gateway";
                        } else {
                            changeType = "relay";
                        }

                        //if (changeType == "gateway") {
                        //    if (changeIsActive) {
                        //        node.data.color = 'green';
                        //    } else {
                        //        node.data.color = 'black';
                        //    }
                        //}
                        //if (changeType == "relay") {
                        //    if (changeIsActive) {
                        //        node.data.color = '#4d88ff';
                        //    } else {
                        //        node.data.color = 'black';
                        //    }
                        //}
						//if (node.data.isActive) {
						//	//node.data.isActive = false;
						//}
						//else {
						//	//node.data.isActive = true;
						//}
						//node.data.isActive = !node.data.isActive;
						//console.log("After the NetworkElement.isActive is changed: " + node.data.isActive);
						//node.data.color = 'black';
						//console.log(" IP : " + ip + " is not active/inactive in js");
					}
				});

                //here is where you change how something looks if it is active or inactive after the call..
                changeColor(changeID, changeType, changeIsActive);
				
				//this ajax call updates the database
				var url = '/Network/SaveNoteInformation';
				$.ajax({
					type: 'POST',
					url: url,
					data: obj,
					dataType: 'json',
					contentType: 'application/json;charset=utf-8',
                    success: function (data) {
                        console.log("after successfully call ajax, data: ",data)
						alert(data);
						$("#NodePopup").html("");
                        $("#NodePopup").modal('hide');
					},
					//error: function (errMsg) {
					//	alert("not update the data");
					//	$("#NodePopup").html("");
					//}
				});
				//hides the modal after success
				$("#NodePopup").html("");
				$('#myModal').modal('hide')
			}
			else {
				$("#NodePopup").html("");
			}
        }
      

		/* ================================================================================================
										Process Transaction Section 
			-This is called when one of the transactions are clicked on (on the Processing Center popup window)
			-It retuns a status response that prints out to the console right now. 
		===================================================================================================*/

		function processTransactionButton(event) {
			console.log("this transaction was clicked: " + event);

			var returnText = "";
			obj = {};
			obj['transId'] = event;
			obj = JSON.stringify(obj);
			console.log(obj);
			var url = '/Transactions/ProcessTransaction';
			$.ajax({
				type: 'POST',
				url: url,
				data: obj,
				dataType: 'json',
				contentType: 'application/json;charset=utf-8',
				success: function (response) {
					console.log("returned correctly...");
					//if the transaction succeeded.
					if (response.success) {
						$("#NodePopup").html("");
						$("#NodePopup").modal('hide');
						console.log(response.responseText);
						printResponse(response.responseText);
					}
					//if the transaction failed.
					else {
						// DoSomethingElse()
						$("#NodePopup").html("");
						$("#NodePopup").modal('hide');
						console.log(response.responseText);
						printResponse(response.responseText)
					}
				},
				failure: function (errMsg) {
					console.log("bad bug");
				}
			});

			//hides the modal after success
			$("#NodePopup").html("");
			$('#myModal').modal('hide')

            //here is where you sent animation back
            var backPath = backQueue.reverse();
            console.log("backTo store, look at the path : ", backPath,"back");
            backToStore("192.168.0.1", backPath, backPath.length);
		}

		function printResponse(response) {
			alert(response);
		}


    </script>
}
